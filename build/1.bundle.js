webpackJsonp([1],{

/***/ 24:
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n * Add dataset support to elements\n * No globals, no overriding prototype with non-standard methods,\n *   handles CamelCase properly, attempts to use standard\n *   Object.defineProperty() (and Function bind()) methods,\n *   falls back to native implementation when existing\n * Inspired by http://code.eligrey.com/html5/dataset/\n *   (via https://github.com/adalgiso/html5-dataset/blob/master/html5-dataset.js )\n * Depends on Function.bind and Object.defineProperty/Object.getOwnPropertyDescriptor (polyfills below)\n * All code below is Licensed under the X11/MIT License\n*/\n\n// Inspired by https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind#Compatibility\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n        'use strict';\n\n        if (typeof this !== \"function\") {\n            // closest thing possible to the ECMAScript 5 internal IsCallable function\n            throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n        }\n\n        var aArgs = Array.prototype.slice.call(arguments, 1),\n            fToBind = this,\n            FNOP = function FNOP() {},\n            fBound = function fBound() {\n            return fToBind.apply(this instanceof FNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n        FNOP.prototype = this.prototype;\n        fBound.prototype = new FNOP();\n\n        return fBound;\n    };\n}\n\n/*\n * Xccessors Standard: Cross-browser ECMAScript 5 accessors\n * http://purl.eligrey.com/github/Xccessors\n *\n * 2010-06-21\n *\n * By Eli Grey, http://eligrey.com\n *\n * A shim that partially implements Object.defineProperty,\n * Object.getOwnPropertyDescriptor, and Object.defineProperties in browsers that have\n * legacy __(define|lookup)[GS]etter__ support.\n *\n * Licensed under the X11/MIT License\n *   See LICENSE.md\n*/\n\n// Removed a few JSLint options as Notepad++ JSLint validator complaining and\n//   made comply with JSLint; also moved 'use strict' inside function\n/*jslint white: true, undef: true, plusplus: true,\n  bitwise: true, regexp: true, newcap: true, maxlen: 90 */\n\n/*! @source http://purl.eligrey.com/github/Xccessors/blob/master/xccessors-standard.js*/\n\n(function () {\n    'use strict';\n\n    var ObjectProto = Object.prototype,\n        defineGetter = ObjectProto.__defineGetter__,\n        defineSetter = ObjectProto.__defineSetter__,\n        lookupGetter = ObjectProto.__lookupGetter__,\n        lookupSetter = ObjectProto.__lookupSetter__,\n        hasOwnProp = ObjectProto.hasOwnProperty;\n\n    if (defineGetter && defineSetter && lookupGetter && lookupSetter) {\n\n        if (!Object.defineProperty) {\n            Object.defineProperty = function (obj, prop, descriptor) {\n                if (arguments.length < 3) {\n                    // all arguments required\n                    throw new TypeError(\"Arguments not optional\");\n                }\n\n                prop += \"\"; // convert prop to string\n\n                if (hasOwnProp.call(descriptor, \"value\")) {\n                    if (!lookupGetter.call(obj, prop) && !lookupSetter.call(obj, prop)) {\n                        // data property defined and no pre-existing accessors\n                        obj[prop] = descriptor.value;\n                    }\n\n                    if (hasOwnProp.call(descriptor, \"get\") || hasOwnProp.call(descriptor, \"set\")) {\n                        // descriptor has a value prop but accessor already exists\n                        throw new TypeError(\"Cannot specify an accessor and a value\");\n                    }\n                }\n\n                // can't switch off these features in ECMAScript 3\n                // so throw a TypeError if any are false\n                if (!(descriptor.writable && descriptor.enumerable && descriptor.configurable)) {\n                    throw new TypeError(\"This implementation of Object.defineProperty does not support\" + \" false for configurable, enumerable, or writable.\");\n                }\n\n                if (descriptor.get) {\n                    defineGetter.call(obj, prop, descriptor.get);\n                }\n                if (descriptor.set) {\n                    defineSetter.call(obj, prop, descriptor.set);\n                }\n\n                return obj;\n            };\n        }\n\n        if (!Object.getOwnPropertyDescriptor) {\n            Object.getOwnPropertyDescriptor = function (obj, prop) {\n                if (arguments.length < 2) {\n                    // all arguments required\n                    throw new TypeError(\"Arguments not optional.\");\n                }\n\n                prop += \"\"; // convert prop to string\n\n                var descriptor = {\n                    configurable: true,\n                    enumerable: true,\n                    writable: true\n                },\n                    getter = lookupGetter.call(obj, prop),\n                    setter = lookupSetter.call(obj, prop);\n\n                if (!hasOwnProp.call(obj, prop)) {\n                    // property doesn't exist or is inherited\n                    return descriptor;\n                }\n                if (!getter && !setter) {\n                    // not an accessor so return prop\n                    descriptor.value = obj[prop];\n                    return descriptor;\n                }\n\n                // there is an accessor, remove descriptor.writable;\n                // populate descriptor.get and descriptor.set (IE's behavior)\n                delete descriptor.writable;\n                descriptor.get = descriptor.set = undefined;\n\n                if (getter) {\n                    descriptor.get = getter;\n                }\n                if (setter) {\n                    descriptor.set = setter;\n                }\n\n                return descriptor;\n            };\n        }\n\n        if (!Object.defineProperties) {\n            Object.defineProperties = function (obj, props) {\n                var prop;\n                for (prop in props) {\n                    if (hasOwnProp.call(props, prop)) {\n                        Object.defineProperty(obj, prop, props[prop]);\n                    }\n                }\n            };\n        }\n    }\n})();\n\n// Begin dataset code\n\nif (!document.documentElement.dataset && (\n// FF is empty while IE gives empty object\n!Object.getOwnPropertyDescriptor(Element.prototype, 'dataset') || !Object.getOwnPropertyDescriptor(Element.prototype, 'dataset').get)) {\n    var propDescriptor = {\n        enumerable: true,\n        get: function get() {\n            'use strict';\n\n            var i,\n                that = this,\n                HTML5_DOMStringMap,\n                attrVal,\n                attrName,\n                propName,\n                attribute,\n                attributes = this.attributes,\n                attsLength = attributes.length,\n                toUpperCase = function toUpperCase(n0) {\n                return n0.charAt(1).toUpperCase();\n            },\n                getter = function getter() {\n                return this;\n            },\n                setter = function setter(attrName, value) {\n                return typeof value !== 'undefined' ? this.setAttribute(attrName, value) : this.removeAttribute(attrName);\n            };\n            try {\n                // Simulate DOMStringMap w/accessor support\n                // Test setting accessor on normal object\n                ({}).__defineGetter__('test', function () {});\n                HTML5_DOMStringMap = {};\n            } catch (e1) {\n                // Use a DOM object for IE8\n                HTML5_DOMStringMap = document.createElement('div');\n            }\n            for (i = 0; i < attsLength; i++) {\n                attribute = attributes[i];\n                // Fix: This test really should allow any XML Name without\n                //         colons (and non-uppercase for XHTML)\n                if (attribute && attribute.name && /^data-\\w[\\w\\-]*$/.test(attribute.name)) {\n                    attrVal = attribute.value;\n                    attrName = attribute.name;\n                    // Change to CamelCase\n                    propName = attrName.substr(5).replace(/-./g, toUpperCase);\n                    try {\n                        Object.defineProperty(HTML5_DOMStringMap, propName, {\n                            enumerable: this.enumerable,\n                            get: getter.bind(attrVal || ''),\n                            set: setter.bind(that, attrName)\n                        });\n                    } catch (e2) {\n                        // if accessors are not working\n                        HTML5_DOMStringMap[propName] = attrVal;\n                    }\n                }\n            }\n            return HTML5_DOMStringMap;\n        }\n    };\n    try {\n        // FF enumerates over element's dataset, but not\n        //   Element.prototype.dataset; IE9 iterates over both\n        Object.defineProperty(Element.prototype, 'dataset', propDescriptor);\n    } catch (e) {\n        propDescriptor.enumerable = false; // IE8 does not allow setting to true\n        Object.defineProperty(Element.prototype, 'dataset', propDescriptor);\n    }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvamF2YXNjcmlwdC9wb2x5ZmlsbHMvZGF0YXNldC5qcz9jMjZkIl0sIm5hbWVzIjpbIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYmluZCIsIm9UaGlzIiwiVHlwZUVycm9yIiwiYUFyZ3MiLCJBcnJheSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImZUb0JpbmQiLCJGTk9QIiwiZkJvdW5kIiwiYXBwbHkiLCJjb25jYXQiLCJPYmplY3RQcm90byIsIk9iamVjdCIsImRlZmluZUdldHRlciIsIl9fZGVmaW5lR2V0dGVyX18iLCJkZWZpbmVTZXR0ZXIiLCJfX2RlZmluZVNldHRlcl9fIiwibG9va3VwR2V0dGVyIiwiX19sb29rdXBHZXR0ZXJfXyIsImxvb2t1cFNldHRlciIsIl9fbG9va3VwU2V0dGVyX18iLCJoYXNPd25Qcm9wIiwiaGFzT3duUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsInByb3AiLCJkZXNjcmlwdG9yIiwibGVuZ3RoIiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJzZXQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJ1bmRlZmluZWQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImRhdGFzZXQiLCJFbGVtZW50IiwicHJvcERlc2NyaXB0b3IiLCJpIiwidGhhdCIsIkhUTUw1X0RPTVN0cmluZ01hcCIsImF0dHJWYWwiLCJhdHRyTmFtZSIsInByb3BOYW1lIiwiYXR0cmlidXRlIiwiYXR0cmlidXRlcyIsImF0dHNMZW5ndGgiLCJ0b1VwcGVyQ2FzZSIsIm4wIiwiY2hhckF0Iiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZTEiLCJjcmVhdGVFbGVtZW50IiwibmFtZSIsInRlc3QiLCJzdWJzdHIiLCJyZXBsYWNlIiwiZTIiLCJl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LCtCQUFPVyxjQUFQLENBQXNCd0Isa0JBQXRCLEVBQTBDRyxRQUExQyxFQUFvRDtBQUNoRHBCLHdDQUFZLEtBQUtBLFVBRCtCO0FBRWhERSxpQ0FBS0csT0FBT3JDLElBQVAsQ0FBWWtELFdBQVcsRUFBdkIsQ0FGMkM7QUFHaERmLGlDQUFLRyxPQUFPdEMsSUFBUCxDQUFZZ0QsSUFBWixFQUFrQkcsUUFBbEI7QUFIMkMseUJBQXBEO0FBS0gscUJBTkQsQ0FPQSxPQUFPZ0IsRUFBUCxFQUFXO0FBQUU7QUFDVGxCLDJDQUFtQkcsUUFBbkIsSUFBK0JGLE9BQS9CO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsbUJBQU9ELGtCQUFQO0FBQ0g7QUFyRGdCLEtBQXJCO0FBdURBLFFBQUk7QUFDQTtBQUNBO0FBQ0FuQyxlQUFPVyxjQUFQLENBQXNCb0IsUUFBUTlDLFNBQTlCLEVBQXlDLFNBQXpDLEVBQW9EK0MsY0FBcEQ7QUFDSCxLQUpELENBSUUsT0FBT3NCLENBQVAsRUFBVTtBQUNSdEIsdUJBQWVkLFVBQWYsR0FBNEIsS0FBNUIsQ0FEUSxDQUMyQjtBQUNuQ2xCLGVBQU9XLGNBQVAsQ0FBc0JvQixRQUFROUMsU0FBOUIsRUFBeUMsU0FBekMsRUFBb0QrQyxjQUFwRDtBQUNIO0FBQ0oiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFkZCBkYXRhc2V0IHN1cHBvcnQgdG8gZWxlbWVudHNcbiAqIE5vIGdsb2JhbHMsIG5vIG92ZXJyaWRpbmcgcHJvdG90eXBlIHdpdGggbm9uLXN0YW5kYXJkIG1ldGhvZHMsXG4gKiAgIGhhbmRsZXMgQ2FtZWxDYXNlIHByb3Blcmx5LCBhdHRlbXB0cyB0byB1c2Ugc3RhbmRhcmRcbiAqICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgKGFuZCBGdW5jdGlvbiBiaW5kKCkpIG1ldGhvZHMsXG4gKiAgIGZhbGxzIGJhY2sgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIHdoZW4gZXhpc3RpbmdcbiAqIEluc3BpcmVkIGJ5IGh0dHA6Ly9jb2RlLmVsaWdyZXkuY29tL2h0bWw1L2RhdGFzZXQvXG4gKiAgICh2aWEgaHR0cHM6Ly9naXRodWIuY29tL2FkYWxnaXNvL2h0bWw1LWRhdGFzZXQvYmxvYi9tYXN0ZXIvaHRtbDUtZGF0YXNldC5qcyApXG4gKiBEZXBlbmRzIG9uIEZ1bmN0aW9uLmJpbmQgYW5kIE9iamVjdC5kZWZpbmVQcm9wZXJ0eS9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIChwb2x5ZmlsbHMgYmVsb3cpXG4gKiBBbGwgY29kZSBiZWxvdyBpcyBMaWNlbnNlZCB1bmRlciB0aGUgWDExL01JVCBMaWNlbnNlXG4qL1xuXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQjQ29tcGF0aWJpbGl0eVxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgICAgICBGTk9QID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBGTk9QICYmIG9UaGlzID8gdGhpcyA6IG9UaGlzLFxuICAgICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgRk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBGTk9QKCk7XG5cbiAgICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICB9O1xufVxuXG4vKlxuICogWGNjZXNzb3JzIFN0YW5kYXJkOiBDcm9zcy1icm93c2VyIEVDTUFTY3JpcHQgNSBhY2Nlc3NvcnNcbiAqIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9YY2Nlc3NvcnNcbiAqXG4gKiAyMDEwLTA2LTIxXG4gKlxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuICpcbiAqIEEgc2hpbSB0aGF0IHBhcnRpYWxseSBpbXBsZW1lbnRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAqIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIGFuZCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyBpbiBicm93c2VycyB0aGF0IGhhdmVcbiAqIGxlZ2FjeSBfXyhkZWZpbmV8bG9va3VwKVtHU11ldHRlcl9fIHN1cHBvcnQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFgxMS9NSVQgTGljZW5zZVxuICogICBTZWUgTElDRU5TRS5tZFxuKi9cblxuLy8gUmVtb3ZlZCBhIGZldyBKU0xpbnQgb3B0aW9ucyBhcyBOb3RlcGFkKysgSlNMaW50IHZhbGlkYXRvciBjb21wbGFpbmluZyBhbmRcbi8vICAgbWFkZSBjb21wbHkgd2l0aCBKU0xpbnQ7IGFsc28gbW92ZWQgJ3VzZSBzdHJpY3QnIGluc2lkZSBmdW5jdGlvblxuLypqc2xpbnQgd2hpdGU6IHRydWUsIHVuZGVmOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSxcbiAgYml0d2lzZTogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBuZXdjYXA6IHRydWUsIG1heGxlbjogOTAgKi9cblxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL1hjY2Vzc29ycy9ibG9iL21hc3Rlci94Y2Nlc3NvcnMtc3RhbmRhcmQuanMqL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgIGRlZmluZUdldHRlciA9IE9iamVjdFByb3RvLl9fZGVmaW5lR2V0dGVyX18sXG4gICAgZGVmaW5lU2V0dGVyID0gT2JqZWN0UHJvdG8uX19kZWZpbmVTZXR0ZXJfXyxcbiAgICBsb29rdXBHZXR0ZXIgPSBPYmplY3RQcm90by5fX2xvb2t1cEdldHRlcl9fLFxuICAgIGxvb2t1cFNldHRlciA9IE9iamVjdFByb3RvLl9fbG9va3VwU2V0dGVyX18sXG4gICAgaGFzT3duUHJvcCA9IE9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgaWYgKGRlZmluZUdldHRlciAmJiBkZWZpbmVTZXR0ZXIgJiYgbG9va3VwR2V0dGVyICYmIGxvb2t1cFNldHRlcikge1xuXG4gICAgICAgIGlmICghT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7IC8vIGFsbCBhcmd1bWVudHMgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50cyBub3Qgb3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvcCArPSBcIlwiOyAvLyBjb252ZXJ0IHByb3AgdG8gc3RyaW5nXG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKGRlc2NyaXB0b3IsIFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rdXBHZXR0ZXIuY2FsbChvYmosIHByb3ApICYmICFsb29rdXBTZXR0ZXIuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIHByb3BlcnR5IGRlZmluZWQgYW5kIG5vIHByZS1leGlzdGluZyBhY2Nlc3NvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoKGhhc093blByb3AuY2FsbChkZXNjcmlwdG9yLCBcImdldFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhhc093blByb3AuY2FsbChkZXNjcmlwdG9yLCBcInNldFwiKSkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlc2NyaXB0b3IgaGFzIGEgdmFsdWUgcHJvcCBidXQgYWNjZXNzb3IgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBhbiBhY2Nlc3NvciBhbmQgYSB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhbid0IHN3aXRjaCBvZmYgdGhlc2UgZmVhdHVyZXMgaW4gRUNNQVNjcmlwdCAzXG4gICAgICAgICAgICAgICAgLy8gc28gdGhyb3cgYSBUeXBlRXJyb3IgaWYgYW55IGFyZSBmYWxzZVxuICAgICAgICAgICAgICAgIGlmICghKGRlc2NyaXB0b3Iud3JpdGFibGUgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlRoaXMgaW1wbGVtZW50YXRpb24gb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5IGRvZXMgbm90IHN1cHBvcnRcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBmYWxzZSBmb3IgY29uZmlndXJhYmxlLCBlbnVtZXJhYmxlLCBvciB3cml0YWJsZS5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVHZXR0ZXIuY2FsbChvYmosIHByb3AsIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVNldHRlci5jYWxsKG9iaiwgcHJvcCwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyAvLyBhbGwgYXJndW1lbnRzIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgbm90IG9wdGlvbmFsLlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9wICs9IFwiXCI7IC8vIGNvbnZlcnQgcHJvcCB0byBzdHJpbmdcblxuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGUgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGUgICAgOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBsb29rdXBHZXR0ZXIuY2FsbChvYmosIHByb3ApLFxuICAgICAgICAgICAgICAgIHNldHRlciA9IGxvb2t1cFNldHRlci5jYWxsKG9iaiwgcHJvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhc093blByb3AuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3Qgb3IgaXMgaW5oZXJpdGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWdldHRlciAmJiAhc2V0dGVyKSB7IC8vIG5vdCBhbiBhY2Nlc3NvciBzbyByZXR1cm4gcHJvcFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBhbiBhY2Nlc3NvciwgcmVtb3ZlIGRlc2NyaXB0b3Iud3JpdGFibGU7XG4gICAgICAgICAgICAgICAgLy8gcG9wdWxhdGUgZGVzY3JpcHRvci5nZXQgYW5kIGRlc2NyaXB0b3Iuc2V0IChJRSdzIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkZXNjcmlwdG9yLndyaXRhYmxlO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZGVzY3JpcHRvci5zZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZ2V0dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2V0dGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcDtcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AuY2FsbChwcm9wcywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHByb3BzW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KCkpO1xuXG4vLyBCZWdpbiBkYXRhc2V0IGNvZGVcblxuaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldCAmJlxuICAgICAgICAgLy8gRkYgaXMgZW1wdHkgd2hpbGUgSUUgZ2l2ZXMgZW1wdHkgb2JqZWN0XG4gICAgICAgICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgJ2RhdGFzZXQnKSAgfHxcbiAgICAgICAgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsICdkYXRhc2V0JykuZ2V0KVxuICAgICkge1xuICAgIHZhciBwcm9wRGVzY3JpcHRvciA9IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBIVE1MNV9ET01TdHJpbmdNYXAsXG4gICAgICAgICAgICAgICAgYXR0clZhbCwgYXR0ck5hbWUsIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGF0dHNMZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0b1VwcGVyQ2FzZSA9IGZ1bmN0aW9uIChuMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjAuY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24gKGF0dHJOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkgeyAvLyBTaW11bGF0ZSBET01TdHJpbmdNYXAgdy9hY2Nlc3NvciBzdXBwb3J0XG4gICAgICAgICAgICAgICAgLy8gVGVzdCBzZXR0aW5nIGFjY2Vzc29yIG9uIG5vcm1hbCBvYmplY3RcbiAgICAgICAgICAgICAgICAoe30pLl9fZGVmaW5lR2V0dGVyX18oJ3Rlc3QnLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgSFRNTDVfRE9NU3RyaW5nTWFwID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZTEpIHsgLy8gVXNlIGEgRE9NIG9iamVjdCBmb3IgSUU4XG4gICAgICAgICAgICAgICAgSFRNTDVfRE9NU3RyaW5nTWFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBGaXg6IFRoaXMgdGVzdCByZWFsbHkgc2hvdWxkIGFsbG93IGFueSBYTUwgTmFtZSB3aXRob3V0XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBjb2xvbnMgKGFuZCBub24tdXBwZXJjYXNlIGZvciBYSFRNTClcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICgvXmRhdGEtXFx3W1xcd1xcLV0qJC8pLnRlc3QoYXR0cmlidXRlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJWYWwgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0byBDYW1lbENhc2VcbiAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUgPSBhdHRyTmFtZS5zdWJzdHIoNSkucmVwbGFjZSgvLS4vZywgdG9VcHBlckNhc2UpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUw1X0RPTVN0cmluZ01hcCwgcHJvcE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0aGlzLmVudW1lcmFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIuYmluZChhdHRyVmFsIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IHNldHRlci5iaW5kKHRoYXQsIGF0dHJOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUyKSB7IC8vIGlmIGFjY2Vzc29ycyBhcmUgbm90IHdvcmtpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIEhUTUw1X0RPTVN0cmluZ01hcFtwcm9wTmFtZV0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEhUTUw1X0RPTVN0cmluZ01hcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRkYgZW51bWVyYXRlcyBvdmVyIGVsZW1lbnQncyBkYXRhc2V0LCBidXQgbm90XG4gICAgICAgIC8vICAgRWxlbWVudC5wcm90b3R5cGUuZGF0YXNldDsgSUU5IGl0ZXJhdGVzIG92ZXIgYm90aFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudC5wcm90b3R5cGUsICdkYXRhc2V0JywgcHJvcERlc2NyaXB0b3IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvcERlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlOyAvLyBJRTggZG9lcyBub3QgYWxsb3cgc2V0dGluZyB0byB0cnVlXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50LnByb3RvdHlwZSwgJ2RhdGFzZXQnLCBwcm9wRGVzY3JpcHRvcik7XG4gICAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvamF2YXNjcmlwdC9wb2x5ZmlsbHMvZGF0YXNldC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 25:
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/*\n * classList.js: Cross-browser full element.classList implementation.\n * 1.1.20150312\n *\n * By Eli Grey, http://eligrey.com\n * License: Dedicated to the public domain.\n *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md\n */\n\n/*global self, document, DOMException */\n\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */\n\nif (\"document\" in self) {\n\n  // Full polyfill for browsers with no classList support\n  // Including IE < Edge missing SVGElement.classList\n  if (!(\"classList\" in document.createElement(\"_\")) || document.createElementNS && !(\"classList\" in document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"))) {\n\n    (function (view) {\n\n      \"use strict\";\n\n      if (!('Element' in view)) return;\n\n      var classListProp = \"classList\",\n          protoProp = \"prototype\",\n          elemCtrProto = view.Element[protoProp],\n          objCtr = Object,\n          strTrim = String[protoProp].trim || function () {\n        return this.replace(/^\\s+|\\s+$/g, \"\");\n      },\n          arrIndexOf = Array[protoProp].indexOf || function (item) {\n        var i = 0,\n            len = this.length;\n        for (; i < len; i++) {\n          if (i in this && this[i] === item) {\n            return i;\n          }\n        }\n        return -1;\n      }\n      // Vendors: please allow content code to instantiate DOMExceptions\n      ,\n          DOMEx = function DOMEx(type, message) {\n        this.name = type;\n        this.code = DOMException[type];\n        this.message = message;\n      },\n          checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {\n        if (token === \"\") {\n          throw new DOMEx(\"SYNTAX_ERR\", \"An invalid or illegal string was specified\");\n        }\n        if (/\\s/.test(token)) {\n          throw new DOMEx(\"INVALID_CHARACTER_ERR\", \"String contains an invalid character\");\n        }\n        return arrIndexOf.call(classList, token);\n      },\n          ClassList = function ClassList(elem) {\n        var trimmedClasses = strTrim.call(elem.getAttribute(\"class\") || \"\"),\n            classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : [],\n            i = 0,\n            len = classes.length;\n        for (; i < len; i++) {\n          this.push(classes[i]);\n        }\n        this._updateClassName = function () {\n          elem.setAttribute(\"class\", this.toString());\n        };\n      },\n          classListProto = ClassList[protoProp] = [],\n          classListGetter = function classListGetter() {\n        return new ClassList(this);\n      };\n      // Most DOMException implementations don't allow calling DOMException's toString()\n      // on non-DOMExceptions. Error's toString() is sufficient here.\n      DOMEx[protoProp] = Error[protoProp];\n      classListProto.item = function (i) {\n        return this[i] || null;\n      };\n      classListProto.contains = function (token) {\n        token += \"\";\n        return checkTokenAndGetIndex(this, token) !== -1;\n      };\n      classListProto.add = function () {\n        var tokens = arguments,\n            i = 0,\n            l = tokens.length,\n            token,\n            updated = false;\n        do {\n          token = tokens[i] + \"\";\n          if (checkTokenAndGetIndex(this, token) === -1) {\n            this.push(token);\n            updated = true;\n          }\n        } while (++i < l);\n\n        if (updated) {\n          this._updateClassName();\n        }\n      };\n      classListProto.remove = function () {\n        var tokens = arguments,\n            i = 0,\n            l = tokens.length,\n            token,\n            updated = false,\n            index;\n        do {\n          token = tokens[i] + \"\";\n          index = checkTokenAndGetIndex(this, token);\n          while (index !== -1) {\n            this.splice(index, 1);\n            updated = true;\n            index = checkTokenAndGetIndex(this, token);\n          }\n        } while (++i < l);\n\n        if (updated) {\n          this._updateClassName();\n        }\n      };\n      classListProto.toggle = function (token, force) {\n        token += \"\";\n\n        var result = this.contains(token),\n            method = result ? force !== true && \"remove\" : force !== false && \"add\";\n\n        if (method) {\n          this[method](token);\n        }\n\n        if (force === true || force === false) {\n          return force;\n        } else {\n          return !result;\n        }\n      };\n      classListProto.toString = function () {\n        return this.join(\" \");\n      };\n\n      if (objCtr.defineProperty) {\n        var classListPropDesc = {\n          get: classListGetter,\n          enumerable: true,\n          configurable: true\n        };\n        try {\n          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n        } catch (ex) {\n          // IE 8 doesn't support enumerable:true\n          if (ex.number === -0x7FF5EC54) {\n            classListPropDesc.enumerable = false;\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n          }\n        }\n      } else if (objCtr[protoProp].__defineGetter__) {\n        elemCtrProto.__defineGetter__(classListProp, classListGetter);\n      }\n    })(self);\n  } else {\n    // There is full or partial native classList support, so just check if we need\n    // to normalize the add/remove and toggle APIs.\n\n    (function () {\n      \"use strict\";\n\n      var testElement = document.createElement(\"_\");\n\n      testElement.classList.add(\"c1\", \"c2\");\n\n      // Polyfill for IE 10/11 and Firefox <26, where classList.add and\n      // classList.remove exist but support only one argument at a time.\n      if (!testElement.classList.contains(\"c2\")) {\n        var createMethod = function createMethod(method) {\n          var original = DOMTokenList.prototype[method];\n\n          DOMTokenList.prototype[method] = function (token) {\n            var i,\n                len = arguments.length;\n\n            for (i = 0; i < len; i++) {\n              token = arguments[i];\n              original.call(this, token);\n            }\n          };\n        };\n        createMethod('add');\n        createMethod('remove');\n      }\n\n      testElement.classList.toggle(\"c3\", false);\n\n      // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n      // support the second argument.\n      if (testElement.classList.contains(\"c3\")) {\n        var _toggle = DOMTokenList.prototype.toggle;\n\n        DOMTokenList.prototype.toggle = function (token, force) {\n          if (1 in arguments && !this.contains(token) === !force) {\n            return force;\n          } else {\n            return _toggle.call(this, token);\n          }\n        };\n      }\n\n      testElement = null;\n    })();\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvamF2YXNjcmlwdC9wb2x5ZmlsbHMvY2xhc3NMaXN0LmpzPzM4MTUiXSwibmFtZXMiOlsic2VsZiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInZpZXciLCJjbGFzc0xpc3RQcm9wIiwicHJvdG9Qcm9wIiwiZWxlbUN0clByb3RvIiwiRWxlbWVudCIsIm9iakN0ciIsIk9iamVjdCIsInN0clRyaW0iLCJTdHJpbmciLCJ0cmltIiwicmVwbGFjZSIsImFyckluZGV4T2YiLCJBcnJheSIsImluZGV4T2YiLCJpdGVtIiwiaSIsImxlbiIsImxlbmd0aCIsIkRPTUV4IiwidHlwZSIsIm1lc3NhZ2UiLCJuYW1lIiwiY29kZSIsIkRPTUV4Y2VwdGlvbiIsImNoZWNrVG9rZW5BbmRHZXRJbmRleCIsImNsYXNzTGlzdCIsInRva2VuIiwidGVzdCIsImNhbGwiLCJDbGFzc0xpc3QiLCJlbGVtIiwidHJpbW1lZENsYXNzZXMiLCJnZXRBdHRyaWJ1dGUiLCJjbGFzc2VzIiwic3BsaXQiLCJwdXNoIiwiX3VwZGF0ZUNsYXNzTmFtZSIsInNldEF0dHJpYnV0ZSIsInRvU3RyaW5nIiwiY2xhc3NMaXN0UHJvdG8iLCJjbGFzc0xpc3RHZXR0ZXIiLCJFcnJvciIsImNvbnRhaW5zIiwiYWRkIiwidG9rZW5zIiwiYXJndW1lbnRzIiwibCIsInVwZGF0ZWQiLCJyZW1vdmUiLCJpbmRleCIsInNwbGljZSIsInRvZ2dsZSIsImZvcmNlIiwicmVzdWx0IiwibWV0aG9kIiwiam9pbiIsImRlZmluZVByb3BlcnR5IiwiY2xhc3NMaXN0UHJvcERlc2MiLCJnZXQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZXgiLCJudW1iZXIiLCJfX2RlZmluZUdldHRlcl9fIiwidGVzdEVsZW1lbnQiLCJjcmVhdGVNZXRob2QiLCJvcmlnaW5hbCIsIkRPTVRva2VuTGlzdCIsInByb3RvdHlwZSIsIl90b2dnbGUiXSwibWFwcGlu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RCxTQVhEO0FBWUF1QyxxQkFBYSxLQUFiO0FBQ0FBLHFCQUFhLFFBQWI7QUFDRDs7QUFFREQsa0JBQVl2QyxTQUFaLENBQXNCMEIsTUFBdEIsQ0FBNkIsSUFBN0IsRUFBbUMsS0FBbkM7O0FBRUE7QUFDQTtBQUNBLFVBQUlhLFlBQVl2QyxTQUFaLENBQXNCaUIsUUFBdEIsQ0FBK0IsSUFBL0IsQ0FBSixFQUEwQztBQUN4QyxZQUFJMkIsVUFBVUYsYUFBYUMsU0FBYixDQUF1QmpCLE1BQXJDOztBQUVBZ0IscUJBQWFDLFNBQWIsQ0FBdUJqQixNQUF2QixHQUFnQyxVQUFTekIsS0FBVCxFQUFnQjBCLEtBQWhCLEVBQXVCO0FBQ3JELGNBQUksS0FBS1AsU0FBTCxJQUFrQixDQUFDLEtBQUtILFFBQUwsQ0FBY2hCLEtBQWQsQ0FBRCxLQUEwQixDQUFDMEIsS0FBakQsRUFBd0Q7QUFDdEQsbUJBQU9BLEtBQVA7QUFDRCxXQUZELE1BRU87QUFDTCxtQkFBT2lCLFFBQVF6QyxJQUFSLENBQWEsSUFBYixFQUFtQkYsS0FBbkIsQ0FBUDtBQUNEO0FBQ0YsU0FORDtBQVFEOztBQUVEc0Msb0JBQWMsSUFBZDtBQUNELEtBNUNBLEdBQUQ7QUE4Q0M7QUFFQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBjbGFzc0xpc3QuanM6IENyb3NzLWJyb3dzZXIgZnVsbCBlbGVtZW50LmNsYXNzTGlzdCBpbXBsZW1lbnRhdGlvbi5cbiAqIDEuMS4yMDE1MDMxMlxuICpcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIExpY2Vuc2U6IERlZGljYXRlZCB0byB0aGUgcHVibGljIGRvbWFpbi5cbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cblxuLypnbG9iYWwgc2VsZiwgZG9jdW1lbnQsIERPTUV4Y2VwdGlvbiAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL2NsYXNzTGlzdC5qcyAqL1xuXG5pZiAoXCJkb2N1bWVudFwiIGluIHNlbGYpIHtcblxuLy8gRnVsbCBwb2x5ZmlsbCBmb3IgYnJvd3NlcnMgd2l0aCBubyBjbGFzc0xpc3Qgc3VwcG9ydFxuLy8gSW5jbHVkaW5nIElFIDwgRWRnZSBtaXNzaW5nIFNWR0VsZW1lbnQuY2xhc3NMaXN0XG5pZiAoIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpKVxuICB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJnXCIpKSkge1xuXG4oZnVuY3Rpb24gKHZpZXcpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICghKCdFbGVtZW50JyBpbiB2aWV3KSkgcmV0dXJuO1xuXG52YXJcbiAgICBjbGFzc0xpc3RQcm9wID0gXCJjbGFzc0xpc3RcIlxuICAsIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCJcbiAgLCBlbGVtQ3RyUHJvdG8gPSB2aWV3LkVsZW1lbnRbcHJvdG9Qcm9wXVxuICAsIG9iakN0ciA9IE9iamVjdFxuICAsIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcbiAgfVxuICAsIGFyckluZGV4T2YgPSBBcnJheVtwcm90b1Byb3BdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXJcbiAgICAgICAgaSA9IDBcbiAgICAgICwgbGVuID0gdGhpcy5sZW5ndGhcbiAgICA7XG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLy8gVmVuZG9yczogcGxlYXNlIGFsbG93IGNvbnRlbnQgY29kZSB0byBpbnN0YW50aWF0ZSBET01FeGNlcHRpb25zXG4gICwgRE9NRXggPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9IHR5cGU7XG4gICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3R5cGVdO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgLCBjaGVja1Rva2VuQW5kR2V0SW5kZXggPSBmdW5jdGlvbiAoY2xhc3NMaXN0LCB0b2tlbikge1xuICAgIGlmICh0b2tlbiA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IERPTUV4KFxuICAgICAgICAgIFwiU1lOVEFYX0VSUlwiXG4gICAgICAgICwgXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKC9cXHMvLnRlc3QodG9rZW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXgoXG4gICAgICAgICAgXCJJTlZBTElEX0NIQVJBQ1RFUl9FUlJcIlxuICAgICAgICAsIFwiU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhcnJJbmRleE9mLmNhbGwoY2xhc3NMaXN0LCB0b2tlbik7XG4gIH1cbiAgLCBDbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhclxuICAgICAgICB0cmltbWVkQ2xhc3NlcyA9IHN0clRyaW0uY2FsbChlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpXG4gICAgICAsIGNsYXNzZXMgPSB0cmltbWVkQ2xhc3NlcyA/IHRyaW1tZWRDbGFzc2VzLnNwbGl0KC9cXHMrLykgOiBbXVxuICAgICAgLCBpID0gMFxuICAgICAgLCBsZW4gPSBjbGFzc2VzLmxlbmd0aFxuICAgIDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLnB1c2goY2xhc3Nlc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICB9O1xuICB9XG4gICwgY2xhc3NMaXN0UHJvdG8gPSBDbGFzc0xpc3RbcHJvdG9Qcm9wXSA9IFtdXG4gICwgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQ2xhc3NMaXN0KHRoaXMpO1xuICB9XG47XG4vLyBNb3N0IERPTUV4Y2VwdGlvbiBpbXBsZW1lbnRhdGlvbnMgZG9uJ3QgYWxsb3cgY2FsbGluZyBET01FeGNlcHRpb24ncyB0b1N0cmluZygpXG4vLyBvbiBub24tRE9NRXhjZXB0aW9ucy4gRXJyb3IncyB0b1N0cmluZygpIGlzIHN1ZmZpY2llbnQgaGVyZS5cbkRPTUV4W3Byb3RvUHJvcF0gPSBFcnJvcltwcm90b1Byb3BdO1xuY2xhc3NMaXN0UHJvdG8uaXRlbSA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiB0aGlzW2ldIHx8IG51bGw7XG59O1xuY2xhc3NMaXN0UHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgdG9rZW4gKz0gXCJcIjtcbiAgcmV0dXJuIGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgIT09IC0xO1xufTtcbmNsYXNzTGlzdFByb3RvLmFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyXG4gICAgICB0b2tlbnMgPSBhcmd1bWVudHNcbiAgICAsIGkgPSAwXG4gICAgLCBsID0gdG9rZW5zLmxlbmd0aFxuICAgICwgdG9rZW5cbiAgICAsIHVwZGF0ZWQgPSBmYWxzZVxuICA7XG4gIGRvIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XG4gICAgaWYgKGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgPT09IC0xKSB7XG4gICAgICB0aGlzLnB1c2godG9rZW4pO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2kgPCBsKTtcblxuICBpZiAodXBkYXRlZCkge1xuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuICB9XG59O1xuY2xhc3NMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXJcbiAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xuICAgICwgaSA9IDBcbiAgICAsIGwgPSB0b2tlbnMubGVuZ3RoXG4gICAgLCB0b2tlblxuICAgICwgdXBkYXRlZCA9IGZhbHNlXG4gICAgLCBpbmRleFxuICA7XG4gIGRvIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XG4gICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xuICAgIHdoaWxlIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpIDwgbCk7XG5cbiAgaWYgKHVwZGF0ZWQpIHtcbiAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcbiAgfVxufTtcbmNsYXNzTGlzdFByb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcbiAgdG9rZW4gKz0gXCJcIjtcblxuICB2YXJcbiAgICAgIHJlc3VsdCA9IHRoaXMuY29udGFpbnModG9rZW4pXG4gICAgLCBtZXRob2QgPSByZXN1bHQgP1xuICAgICAgZm9yY2UgIT09IHRydWUgJiYgXCJyZW1vdmVcIlxuICAgIDpcbiAgICAgIGZvcmNlICE9PSBmYWxzZSAmJiBcImFkZFwiXG4gIDtcblxuICBpZiAobWV0aG9kKSB7XG4gICAgdGhpc1ttZXRob2RdKHRva2VuKTtcbiAgfVxuXG4gIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZm9yY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICFyZXN1bHQ7XG4gIH1cbn07XG5jbGFzc0xpc3RQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuam9pbihcIiBcIik7XG59O1xuXG5pZiAob2JqQ3RyLmRlZmluZVByb3BlcnR5KSB7XG4gIHZhciBjbGFzc0xpc3RQcm9wRGVzYyA9IHtcbiAgICAgIGdldDogY2xhc3NMaXN0R2V0dGVyXG4gICAgLCBlbnVtZXJhYmxlOiB0cnVlXG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfTtcbiAgdHJ5IHtcbiAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XG4gIH0gY2F0Y2ggKGV4KSB7IC8vIElFIDggZG9lc24ndCBzdXBwb3J0IGVudW1lcmFibGU6dHJ1ZVxuICAgIGlmIChleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XG4gICAgICBjbGFzc0xpc3RQcm9wRGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XG4gICAgfVxuICB9XG59IGVsc2UgaWYgKG9iakN0cltwcm90b1Byb3BdLl9fZGVmaW5lR2V0dGVyX18pIHtcbiAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcbn1cblxufShzZWxmKSk7XG5cbn0gZWxzZSB7XG4vLyBUaGVyZSBpcyBmdWxsIG9yIHBhcnRpYWwgbmF0aXZlIGNsYXNzTGlzdCBzdXBwb3J0LCBzbyBqdXN0IGNoZWNrIGlmIHdlIG5lZWRcbi8vIHRvIG5vcm1hbGl6ZSB0aGUgYWRkL3JlbW92ZSBhbmQgdG9nZ2xlIEFQSXMuXG5cbihmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xuXG4gIHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjMVwiLCBcImMyXCIpO1xuXG4gIC8vIFBvbHlmaWxsIGZvciBJRSAxMC8xMSBhbmQgRmlyZWZveCA8MjYsIHdoZXJlIGNsYXNzTGlzdC5hZGQgYW5kXG4gIC8vIGNsYXNzTGlzdC5yZW1vdmUgZXhpc3QgYnV0IHN1cHBvcnQgb25seSBvbmUgYXJndW1lbnQgYXQgYSB0aW1lLlxuICBpZiAoIXRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMyXCIpKSB7XG4gICAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgdmFyIG9yaWdpbmFsID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdO1xuXG4gICAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICB2YXIgaSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0b2tlbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBvcmlnaW5hbC5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNyZWF0ZU1ldGhvZCgnYWRkJyk7XG4gICAgY3JlYXRlTWV0aG9kKCdyZW1vdmUnKTtcbiAgfVxuXG4gIHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJjM1wiLCBmYWxzZSk7XG5cbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwIGFuZCBGaXJlZm94IDwyNCwgd2hlcmUgY2xhc3NMaXN0LnRvZ2dsZSBkb2VzIG5vdFxuICAvLyBzdXBwb3J0IHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjM1wiKSkge1xuICAgIHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XG5cbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKHRva2VuLCBmb3JjZSkge1xuICAgICAgaWYgKDEgaW4gYXJndW1lbnRzICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XG4gICAgICAgIHJldHVybiBmb3JjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgfVxuXG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcbn0oKSk7XG5cbn1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvamF2YXNjcmlwdC9wb2x5ZmlsbHMvY2xhc3NMaXN0LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }

});